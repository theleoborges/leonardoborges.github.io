<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>clojure and why calculating is better than scheming | Leonardo Borges</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Last week while attending Clojure/West in Portland I came across a paper called Why calculating is better than scheming. In a nutshell, this paper is a critique to Abelson and Sussman&rsquo;s classic textbook SICP - Structure and Interpretation of Computer Programs,
used by MIT for many years to teach their introductory programming course.
If you haven&rsquo;t read SICP, you should. It&rsquo;s an amazing book. It uses Scheme, a dialect of Lisp, as the vehicle to present fundamental programming concepts.">
    <meta name="generator" content="Hugo 0.139.4">
    
    
    
      <meta name="robots" content="index, follow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.1a1e856c575c37c0a14fa63fe637fefcac5fc8a9e372c7d8de0184b5ab217407.css" >



    

    
      
<link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon" />


    

    

    
      <link rel="canonical" href="http://leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/">
    

    <meta property="og:url" content="http://leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/">
  <meta property="og:site_name" content="Leonardo Borges">
  <meta property="og:title" content="clojure and why calculating is better than scheming">
  <meta property="og:description" content="Last week while attending Clojure/West in Portland I came across a paper called Why calculating is better than scheming. In a nutshell, this paper is a critique to Abelson and Sussman’s classic textbook SICP - Structure and Interpretation of Computer Programs, used by MIT for many years to teach their introductory programming course.
If you haven’t read SICP, you should. It’s an amazing book. It uses Scheme, a dialect of Lisp, as the vehicle to present fundamental programming concepts.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="writings">
    <meta property="article:published_time" content="2013-03-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2013-03-25T00:00:00+00:00">
    <meta property="article:tag" content="Clojure">
    <meta property="article:tag" content="Functional-Programming">
    <meta property="article:tag" content="Haskell">

  <meta itemprop="name" content="clojure and why calculating is better than scheming">
  <meta itemprop="description" content="Last week while attending Clojure/West in Portland I came across a paper called Why calculating is better than scheming. In a nutshell, this paper is a critique to Abelson and Sussman’s classic textbook SICP - Structure and Interpretation of Computer Programs, used by MIT for many years to teach their introductory programming course.
If you haven’t read SICP, you should. It’s an amazing book. It uses Scheme, a dialect of Lisp, as the vehicle to present fundamental programming concepts.">
  <meta itemprop="datePublished" content="2013-03-25T00:00:00+00:00">
  <meta itemprop="dateModified" content="2013-03-25T00:00:00+00:00">
  <meta itemprop="wordCount" content="1663">
  <meta itemprop="keywords" content="Clojure,Functional-Programming,Haskell">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="clojure and why calculating is better than scheming">
  <meta name="twitter:description" content="Last week while attending Clojure/West in Portland I came across a paper called Why calculating is better than scheming. In a nutshell, this paper is a critique to Abelson and Sussman’s classic textbook SICP - Structure and Interpretation of Computer Programs, used by MIT for many years to teach their introductory programming course.
If you haven’t read SICP, you should. It’s an amazing book. It uses Scheme, a dialect of Lisp, as the vehicle to present fundamental programming concepts.">

      
    
	
  </head><body class="ma0 avenir bg-near-white production">

    
   
  

<header>
    <div class="bg-black">
        <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Leonardo Borges
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/about/" title="About page">
              About
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/books/" title="Books page">
              Books
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://leonardoborges.substack.com/p/leadership-coaching" title="Coaching page">
              Coaching
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="https://leonardoborges.substack.com/" title="Newsletter page">
              Newsletter
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"><a href="https://github.com/theleoborges/" target="_blank" rel="noopener"
        class="ananke-social-link link-transition github link dib z-999 pt3 pt0-l mr1"
        title="follow on GitHub - Opens in a new window"
        aria-label="follow on GitHub - Opens in a new window">
      <span class="icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
            
          </span></a><a href="https://twitter.com/theleoborges" target="_blank" rel="noopener"
        class="ananke-social-link link-transition twitter link dib z-999 pt3 pt0-l mr1"
        title="follow on Twitter - Opens in a new window"
        aria-label="follow on Twitter - Opens in a new window">
      <span class="icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
            
          </span></a><a href="http://linkedin.com/in/theleoborges" target="_blank" rel="noopener"
        class="ananke-social-link link-transition linkedin link dib z-999 pt3 pt0-l mr1"
        title="follow on LinkedIn - Opens in a new window"
        aria-label="follow on LinkedIn - Opens in a new window">
      <span class="icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
            
          </span></a></div>

    </div>
  </div>
</nav>

    </div>
    
</header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Writings
      </aside><div id="sharing" class="mt3 ananke-socials"></div>
<h1 class="f1 athelas mt3 mb1">clojure and why calculating is better than scheming</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2013-03-25T00:00:00Z">March 25, 2013</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Last week while attending <a href="http://clojurewest.org">Clojure/West</a> in Portland I came across a paper called <a href="http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf">Why calculating is better than scheming</a>. In a nutshell, this paper is a critique to <a href="http://en.wikipedia.org/wiki/Hal_Abelson">Abelson</a> and <a href="http://en.wikipedia.org/wiki/Gerald_Jay_Sussman">Sussman</a>&rsquo;s classic textbook <a href="http://mitpress.mit.edu/sicp/">SICP - Structure and Interpretation of Computer Programs</a>,
used by MIT for many years to teach their introductory programming course.</p>
<p>If you haven&rsquo;t read <a href="http://mitpress.mit.edu/sicp/">SICP</a>, you should. It&rsquo;s an amazing book. It uses <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, a dialect of Lisp, as the vehicle to present fundamental programming concepts.</p>
<p><a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a> - the author of this particular paper - contrasts teaching in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a> to teaching using <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> and <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a>, pointing out
four major features he considers important and lacking in <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>. They are:</p>
<ul>
<li>Pattern matching</li>
<li>A syntax close to traditional mathematical notation</li>
<li>A static type discipline and user-defined types</li>
<li>Lazy Evaluation</li>
</ul>
<blockquote>
<p>Note:  <a href="http://en.wikipedia.org/wiki/Kent_Recursive_Calculator">KRC</a> influenced <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a> which in turn influenced <a href="http://www.haskell.org/haskellwiki/Haskell">Haskell</a>.  Their syntax is similiar, so where Wadler used Miranda code snippets in the paper, I&rsquo;ll be using Haskell in this post.</p>
</blockquote>
<p>As an aside, although the paper talks specifically of <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">Scheme</a>, the term Lisp is used quite loosely and could lead the not-so-careful reader to be misled regarding a whole family of languages. Lisps have come a long way and modern dialects - of which I&rsquo;ll be focusing on <a href="http://clojure.org/">Clojure</a> - address many of the concerns raised by <a href="http://homepages.inf.ed.ac.uk/wadler/">Wadler</a>.</p>
<p>Let us begin.</p>
<h3 id="pattern-matching">Pattern Matching</h3>
<p>Here Clojure, and most - all? - Lisps, are out of luck.</p>
<p>The example used in the paper is that of summing all integers in a list. First in Haskell:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">sum</span> <span style="color:#66d9ef">[]</span>   <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sum</span> x<span style="color:#66d9ef">:</span>xs <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> sum xs
</span></span></code></pre></div><p>Now in Clojure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>sum [coll]
</span></span><span style="display:flex;"><span>	(<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">empty?</span> coll)
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		(+ (first coll) (<span style="color:#a6e22e">sum</span> (rest coll)))))
</span></span></code></pre></div><p>The question here is this: Which snippet is easier to read/reason about? the Haskell code!</p>
<p>I must confess that I, too, miss pattern matching sometimes. However we can still improve our Clojure version to read nicer on the eyes by using <a href="http://www.haskell.org/haskellwiki/Haskell">destructuring</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>sum [[first <span style="color:#f92672">&amp;</span> rest <span style="color:#e6db74">:as</span> coll]]
</span></span><span style="display:flex;"><span>	(<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">empty?</span> coll)
</span></span><span style="display:flex;"><span>		<span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		(+ first (<span style="color:#a6e22e">sum</span> rest))))
</span></span></code></pre></div><p>And that&rsquo;s pretty much it. Without proper pattern matching, we can&rsquo;t get much better than that.</p>
<p>In addition to the Haskell snippet being easier to read, it&rsquo;s also easier to prove correct by structural induction, as demonstrated in Wadler&rsquo;s paper.</p>
<blockquote>
<p>Note: <a href="https://github.com/clojure/core.match">core.match</a> adds support to pattern matching in Clojure. At the time of this writing, it&rsquo;s considered &ldquo;alpha quality&rdquo;</p>
</blockquote>
<h3 id="data-structures">Data structures</h3>
<p>The paper continues to discuss exercise 2-27 from the <a href="http://mitpress.mit.edu/sicp/">SICP</a>, where the reader has to write code to represent a binary mobile, which consists of a left and right branch with each branch being a rod of certain length, from which hangs either a weight or another binary mobile.</p>
<p>Translating the Scheme example to Clojure, such a structure is represented using lists, like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>make-mobile [left right] 
</span></span><span style="display:flex;"><span>	(list left right))
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>make-branch [length structure]
</span></span><span style="display:flex;"><span>	(list length structure))
</span></span></code></pre></div><p>Wadler then contrasts this with the equivalent Miranda code, translated below to Haskell, taking advantage of <a href="http://www.haskell.org/haskellwiki/Algebraic_data_type">algebraic data types</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Structure</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Weight</span> <span style="color:#66d9ef">Int</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Mobile</span> <span style="color:#66d9ef">Branch</span> <span style="color:#66d9ef">Branch</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Branch</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Branch</span> <span style="color:#66d9ef">Int</span> <span style="color:#66d9ef">Structure</span>
</span></span></code></pre></div><p>The first claim is that the Haskell/Miranda data type declaration makes it clearer what the data structure looks like, which is fair.</p>
<p>Also, the compiler can catch errors early on.</p>
<p>However, when writing idiomatic Clojure code, here&rsquo;s how I&rsquo;d actually create this structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>make-mobile [left right] 
</span></span><span style="display:flex;"><span>	{<span style="color:#e6db74">:left</span> left <span style="color:#e6db74">:right</span> right})
</span></span><span style="display:flex;"><span>	
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>make-branch [length structure]
</span></span><span style="display:flex;"><span>	{<span style="color:#e6db74">:length</span> length <span style="color:#e6db74">:structure</span> structure})
</span></span></code></pre></div><p>Granted, it&rsquo;s still not as clear and the compiler can&rsquo;t validate the shape of our data structure.</p>
<p>This is however cleaner than the previous version and drives home the point that Clojure isn&rsquo;t limited to lists, having literals for other data types such as the hash maps used in this example.</p>
<p>The second part of this claim is that through custom data types and pattern mathing, extracting values from those structures becomes simpler:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">totalWeight</span> (<span style="color:#66d9ef">Weight</span> w) <span style="color:#f92672">=</span> w
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">totalWeight</span> (<span style="color:#66d9ef">Mobile</span> l r) <span style="color:#f92672">=</span> totalWeightBranch l <span style="color:#f92672">+</span> totalWeightBranch r
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">totalWeightBranch</span>(<span style="color:#66d9ef">Branch</span> d s) <span style="color:#f92672">=</span> totalWeight s
</span></span></code></pre></div><p>Once again Clojure can improve things by taking advantage of its builtin data structures and destructuring:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>total-weight [{<span style="color:#e6db74">:keys</span> [left right] <span style="color:#e6db74">:as</span> structure}]
</span></span><span style="display:flex;"><span>	(<span style="color:#66d9ef">if </span>(<span style="color:#a6e22e">number?</span> structure)
</span></span><span style="display:flex;"><span>		structure
</span></span><span style="display:flex;"><span>		(+ (<span style="color:#a6e22e">total-weight-branch</span> left)
</span></span><span style="display:flex;"><span>		   (<span style="color:#a6e22e">total-weight-branch</span> right))))
</span></span><span style="display:flex;"><span>		   
</span></span><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>total-weight-branch [{structure <span style="color:#e6db74">:structure</span>}]
</span></span><span style="display:flex;"><span>	(<span style="color:#a6e22e">total-weight</span> structure))		   
</span></span></code></pre></div><p>For a language with no pattern matching nor algebraic data types, this snippet is clear, concise and elegant - and a real improvement
over the Scheme version discussed in the paper - which was essentially handicapped by the use of lists to simulate &lsquo;structs&rsquo;.</p>
<p>As far as Clojure goes, this claim ends here: the next point in the paper, about changing from using <code>list</code> to using <code>cons</code>, is rendered moot since
we&rsquo;re using hash maps to represent our mobiles.</p>
<h3 id="lisp-lists-are-not-self-escaping">Lisp lists are not self-escaping</h3>
<p>Creating lists in Clojure goes like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(list (list <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>) nil) <span style="color:#75715e">;; ((1 2) nil)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&#39;</span>((<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>) nil) <span style="color:#75715e">;; ((1 2) nil)</span>
</span></span></code></pre></div><p>Both statements above are equivalent, with the second one being clearly more concise.</p>
<p>The claim here is that the fact that you need to either use the <code>list</code> function or quote the form is cumbersome and can be confusing to beginners.</p>
<p>Clojure solves this by providing literals to another data structure - vectors:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>[[<span style="color:#ae81ff">1</span> <span style="color:#ae81ff">2</span>] nil]
</span></span></code></pre></div><p>Simple and concise - in fact, in idiomatic Clojure code, you&rsquo;ll rarely see quoted lists where a vector will do.</p>
<p>This is possible because both lists and vectors conform to a higher level abstraction called a <a href="http://clojure.org/sequences#Sequences-The%20Seq%20library-Seq%20in,%20Seq%20out">Seq</a>, in terms of which most list
operations are defined.</p>
<p>This eliminates the two following points mentioned in the paper as it allows a beginner to defer his/her understanding of quoted forms
to more advanced lessons/usages.</p>
<h3 id="programs-that-manipulate-programs---the-interpreter-example">Programs that Manipulate Programs - the interpreter example</h3>
<p>Here Wadler shows a simple grammar for an interpreter in both Miranda and Scheme.</p>
<p>He claims that since Haskell/Miranda have free data types, representing such grammar becomes simpler:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Term</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Var</span> [<span style="color:#66d9ef">Char</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">|</span> <span style="color:#66d9ef">Lambda</span> <span style="color:#66d9ef">Var</span> <span style="color:#66d9ef">Term</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">|</span> <span style="color:#66d9ef">Apply</span> <span style="color:#66d9ef">Term</span> <span style="color:#66d9ef">Term</span>
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">|</span> <span style="color:#66d9ef">Closure</span> <span style="color:#66d9ef">Env</span> <span style="color:#66d9ef">Var</span> <span style="color:#66d9ef">Term</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Env</span> <span style="color:#f92672">=</span> [(<span style="color:#66d9ef">Var</span>, <span style="color:#66d9ef">Term</span>)] 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Var</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">Char</span>]
</span></span></code></pre></div><p>This is true in that one can easily scan the snippet above and deduce quickly what <code>Term</code> looks like.</p>
<p>Then, by using pattern matching, <code>eval</code> could be implemented like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">eval</span> e (<span style="color:#66d9ef">Var</span> v) <span style="color:#f92672">=</span> lookup e v
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">eval</span> e (<span style="color:#66d9ef">Lambda</span> v t) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Closure</span> e v t
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">eval</span> e (<span style="color:#66d9ef">Apply</span> t0 t1) <span style="color:#f92672">=</span> apply (eval e t0) (eval e t1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span></code></pre></div><p>I do believe this makes Haskell an excellent choice for writing interpreters and compilers.</p>
<p>However, the flip side is that entering such terms in Haskell is cumbersome. Consider the term below:</p>
<blockquote>
<p>(λx.(x x)) (λx.(x x))</p>
</blockquote>
<p>This is how to represent this term using the grammar defined above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(apply (<span style="color:#66d9ef">Lambda</span> <span style="color:#e6db74">&#34;x&#34;</span> (apply (<span style="color:#66d9ef">Var</span> <span style="color:#e6db74">&#34;x&#34;</span>) (<span style="color:#66d9ef">Var</span> <span style="color:#e6db74">&#34;x&#34;</span>))) 
</span></span><span style="display:flex;"><span>       (<span style="color:#66d9ef">Lambda</span> <span style="color:#e6db74">&#34;x&#34;</span> (apply (<span style="color:#66d9ef">Var</span> <span style="color:#e6db74">&#34;x&#34;</span>) (<span style="color:#66d9ef">Var</span> <span style="color:#e6db74">&#34;x&#34;</span>))))
</span></span></code></pre></div><p>The strength in Lisp lies elsewhere. Since we have quoted forms, entering a similar term is a lot less verbose and closer to its intended representation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span><span style="color:#f92672">&#39;</span>((<span style="color:#a6e22e">lambda</span> [x] (<span style="color:#a6e22e">x</span> x)) (<span style="color:#a6e22e">lambda</span> [x] (<span style="color:#a6e22e">x</span> x)))
</span></span></code></pre></div><p>This is, of course, at the expense of making <code>eval</code> a more complicated function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#66d9ef">defn </span>eval [e t] 
</span></span><span style="display:flex;"><span>  (cond (<span style="color:#a6e22e">variable?</span> t)
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">lookup</span> e (<span style="color:#a6e22e">variable-name</span> t))
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">lambda?</span> t)
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">make-closure</span> e (<span style="color:#a6e22e">lambda-var</span> t) (<span style="color:#a6e22e">lambda-body</span> t))
</span></span><span style="display:flex;"><span>        (<span style="color:#a6e22e">apply?</span> t)
</span></span><span style="display:flex;"><span>        (apply (eval e (<span style="color:#a6e22e">apply-operator</span> t))
</span></span><span style="display:flex;"><span>               (eval e (<span style="color:#a6e22e">apply-operand</span> t)))))
</span></span><span style="display:flex;"><span>               
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>The paper leaves out an important advantage of Lisps though:</p>
<p>Because we can write code for our made up language directly in its (almost)abstract syntax tree form, Lisps are the ideal choice when writing <a href="http://martinfowler.com/bliki/InternalDslStyle.html">Internal Domain Specific Languages</a>.</p>
<h3 id="lazy-evaluation">Lazy Evaluation</h3>
<h4 id="lists">Lists</h4>
<p>Haskell and Miranda are lazy languages and that yields a lot of power. This claim is more specific to the use of lazy lists - or sequences, streams - and starts off with a snippet that calculates the sum of squares of all odd numbers from 1 up to 100:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">sum</span> [ i<span style="color:#f92672">*</span>i <span style="color:#f92672">|</span> i <span style="color:#f92672">&lt;-</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">100</span>], odd i ]
</span></span></code></pre></div><p>What follows in the paper is a not-so-clear snippet of equivalent functionality using Scheme streams.</p>
<p>Clojure features lazy sequences and list comprehensions, making the above Haskell example trivial to write:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#a6e22e">sum</span> (for [i (range <span style="color:#ae81ff">100</span>) <span style="color:#e6db74">:when</span> (<span style="color:#a6e22e">odd?</span> i)] (* i i)))
</span></span></code></pre></div><p>If you&rsquo;re following at home with the original paper you&rsquo;ll see this is more readable and elegant than the equivalent Scheme example.</p>
<p>Another - also idiomatic - way to write the same expression is by using a combination of map/filter:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#a6e22e">sum</span> (map <span style="color:#f92672">#</span>(* % %) (filter odd? (range <span style="color:#ae81ff">100</span>))))
</span></span></code></pre></div><p>Deciding which one is clearer is left as an exercise to the reader.</p>
<h4 id="special-forms-and-lazy-evaluation">Special forms and lazy evaluation</h4>
<p>In this section, Wadler brings another example from SICP where the reader wishes to implement his/her own <code>if</code> form.</p>
<p>As we know, in order to implement our own version of <code>if</code>, we need to use macros. That is because in Lisps arguments to functions are eagerly evaluated.</p>
<p>One might implement it like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>(<span style="color:#66d9ef">defmacro </span>my-if [pred then else]
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>(cond <span style="color:#f92672">~</span>pred <span style="color:#f92672">~</span>then
</span></span><span style="display:flex;"><span>  		<span style="color:#e6db74">:else</span> <span style="color:#f92672">~</span>else))
</span></span></code></pre></div><p>In Lazy languages, such as Haskell and Miranda, this problem doesn&rsquo;t occur allowing such functions to be defined without the need for special and/or quoted forms:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#a6e22e">myIf</span> <span style="color:#66d9ef">True</span>  t e <span style="color:#f92672">=</span> t
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">myIf</span> <span style="color:#66d9ef">False</span> t e <span style="color:#f92672">=</span> e
</span></span></code></pre></div><p>However this completely dismisses the power of macros which allow you to extend the language in ways no other language allows - as is extensively demonstrated in books such as <a href="http://amzn.to/14mrrbk">On Lisp</a> and <a href="http://amzn.to/WKpMZA">Let Over Lambda</a>.</p>
<p>As <a href="http://en.wikipedia.org/wiki/Guy_L._Steele,_Jr.">Guy Steele</a> once put it:  <em>&quot;[…] If you give someone Lisp, he has any language he pleases&quot;</em></p>
<h3 id="conclusion">Conclusion</h3>
<p>Hopefully this post doesn&rsquo;t come off as trying to invalidate Wadler&rsquo;s paper - that is not my intention.</p>
<p>While I do think a few of the points discussed are only applicable to the domain in which his paper was written - teaching - they are still valid and worth understanding.</p>
<p>I do however expect to have given you a different perspective on it, showing the strengths of modern Lisps such as Clojure and how it approaches these issues - such as by using its rich set of data structures, literals and techniques such as destructuring.</p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/clojure/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Clojure</a>
   </li>
  
   <li class="list di">
     <a href="/tags/functional-programming/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Functional-Programming</a>
   </li>
  
   <li class="list di">
     <a href="/tags/haskell/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Haskell</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
        <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "leonardoborges" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/writings/2012/12/08/monads-in-small-bites-part-iv-monads/">Monads in small bites - Part IV - Monads</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/12/05/monads-in-small-bites-part-iii-monoids/">Monads in small bites - Part III - Monoids</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/12/02/monads-in-small-bites-part-ii-applicative-functors/">Monads in small bites - Part II - Applicative Functors</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/11/30/monads-in-small-bites-part-i-functors/">Monads in small bites - Part I - Functors</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2013/02/03/purely-functional-data-structures-in-clojure-leftist-heaps/">Purely functional data structures in Clojure: Leftist Heaps</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2013/01/04/bouncer-validation-lib-for-clojure/">bouncer validation lib for clojure</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/09/10/clojure-leiningen-heroku-aot-compilation-gotchas/">Clojure, leiningen 2 and Heroku: AOT compilation gotchas</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/08/23/sean-corfield-clojure-and-cfml-sitting-in-a-tree/">Sean Corfield: Clojure and CFML sitting in a tree</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/02/22/clj-syd-report-number-0/">clj syd report number 0</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/02/05/project-euler-problem-4-in-clojure/">project euler problem 4 in clojure</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/01/22/backlog-ola-bini-on-clojure-conj/">backlog ola bini on clojure conj</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2012/01/20/announcing-the-sydney-clojure-user-group/">announcing the sydney clojure user group</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/writings/2011/10/12/report-clojure-meetup-1/">Report: Clojure Meetup - 1</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://leonardoborges.com/" >
    &copy;  Leonardo Borges 2025 
  </a>
    <div><div class="ananke-socials"><a href="https://github.com/theleoborges/" target="_blank" rel="noopener"
        class="ananke-social-link link-transition github link dib z-999 pt3 pt0-l mr1"
        title="follow on GitHub - Opens in a new window"
        aria-label="follow on GitHub - Opens in a new window">
      <span class="icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
            
          </span></a><a href="https://twitter.com/theleoborges" target="_blank" rel="noopener"
        class="ananke-social-link link-transition twitter link dib z-999 pt3 pt0-l mr1"
        title="follow on Twitter - Opens in a new window"
        aria-label="follow on Twitter - Opens in a new window">
      <span class="icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg>
            
          </span></a><a href="http://linkedin.com/in/theleoborges" target="_blank" rel="noopener"
        class="ananke-social-link link-transition linkedin link dib z-999 pt3 pt0-l mr1"
        title="follow on LinkedIn - Opens in a new window"
        aria-label="follow on LinkedIn - Opens in a new window">
      <span class="icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc. --><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
            
          </span></a></div>
</div>
  </div>
</footer>

  </body>
</html>
