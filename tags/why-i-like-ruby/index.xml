<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Why I Like Ruby on Leonardo Borges</title>
    <link>http://leonardoborges.com/tags/why-i-like-ruby/</link>
    <description>Recent content in Why I Like Ruby on Leonardo Borges</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 Aug 2008 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://leonardoborges.com/tags/why-i-like-ruby/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>why i like ruby 1 alias_method</title>
      <link>http://leonardoborges.com/writings/2008/08/07/why-i-like-ruby-1-alias_method/</link>
      <pubDate>Thu, 07 Aug 2008 00:00:00 +0000</pubDate>
      <guid>http://leonardoborges.com/writings/2008/08/07/why-i-like-ruby-1-alias_method/</guid>
      <description>&lt;p&gt;&#xA;So you found yourself in the need to override a method but still count on it&#39;s old behaviour?&lt;br&gt;&lt;br&gt;No problem! Override it with your new code, call &lt;strong&gt;super&lt;/strong&gt; and.... Uh oh!! Suddenly this turned into a problem... Let me give some more context.&lt;br&gt;&lt;br&gt;I was testing &lt;a href=&#34;http://ferret.davebalmain.com/trac/wiki&#34;&gt;Ferret&lt;/a&gt; (and the &lt;a href=&#34;http://projects.jkraemer.net/acts_as_ferret/&#34;&gt;acts_as_ferret&lt;/a&gt; plugin) in a project to provide full text search capabilities to our models. One of the things the plugin does is to add a new method to ActiveRecord, called &lt;em&gt;find_with_ferret&lt;/em&gt;. That way, every model can use it. Great!&lt;br&gt;&lt;br&gt;So I thought that would make sense for me to remove all &lt;a href=&#34;http://en.wikipedia.org/wiki/Diacritics&#34;&gt;diatrictics&lt;/a&gt; from the input text before letting ferret do its job. You know, like removing &lt;a href=&#34;http://en.wikipedia.org/wiki/Umlaut_%28diacritic%29&#34;&gt;umlauts&lt;/a&gt; and all that.&lt;br&gt;&lt;br&gt;I could do that by overriding this method with code to remove the undesired chars and then call its older version to finally do the search - something like calling super, but not quite. And I didn&#39;t want my models to inherit from anything else than ActiveRecord::Base. That wouldn&#39;t make any sense.&lt;br&gt;&lt;br&gt;&lt;a href=&#34;http://www.ruby-doc.org/core/classes/Module.html#M000395&#34;&gt;alias_method&lt;/a&gt; to the rescue!&lt;br&gt;&lt;br&gt;You know that to redefine a method in an existing class you can open it up and rewrite it. But since you don&#39;t wanna loose the behaviour provided by the original method, this is how you can achieve this:&lt;br&gt;&lt;br&gt;&lt;pre lang=&#34;ruby&#34; line=&#34;1&#34;&gt;&lt;br&gt;module ActiveRecord&lt;br&gt;  class Base&lt;br&gt;    alias_method :find_with_ferret_original, :find_with_ferret&lt;br&gt;&lt;br&gt;    def find_with_ferret(q, options = {}, find_options = {})&lt;br&gt;      remove_diatrictics!(q)&lt;br&gt;      find_with_ferret_original(q, options, find_options)&lt;br&gt;    end&lt;br&gt;  end&lt;br&gt;end&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;And you&#39;re good to go. On line 3 you&#39;re just giving the original method an alias, making a copy of it.&lt;br&gt;&lt;br&gt;Then you redefine it the way you like and on line 6 you call the old version to make sure u still got the same behaviour.  &lt;br&gt;Now all my models can benefit of this change without requiring them to call another method nor inherit from another class.&lt;br&gt;&lt;br&gt;Cool, huh? :)&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>why i like ruby or ruby the language of the lazy programmer</title>
      <link>http://leonardoborges.com/writings/2008/04/01/why-i-like-ruby-or-ruby-the-language-of-the-lazy-programmer/</link>
      <pubDate>Tue, 01 Apr 2008 00:00:00 +0000</pubDate>
      <guid>http://leonardoborges.com/writings/2008/04/01/why-i-like-ruby-or-ruby-the-language-of-the-lazy-programmer/</guid>
      <description>&lt;p&gt;&#xA;This is quite funny. A friend, Perl addicted, is now learning Ruby. He really enjoys the language but made a interesting observation: Ruby is a language for lazy programmers!&lt;br&gt;&lt;br&gt;Well, I have to agree... You know, I love saving keystrokes and achieving more by writing less. And this is so true with Ruby.&lt;br&gt;&lt;br&gt;Let me give a really simple example, comparing with java - don&#39;t get me wrong... I love java, specially the platform, but it fits well here since I&#39;ve always been a Java guy.&lt;br&gt;&lt;br&gt;Imagine you have a Phone class with the attributes number and type, which can indicate whether the phone is a land line or a mobile phone. Then you got an array filled with phone classes and you want to narrow it by creating a new array only with mobile phones.&lt;br&gt;&lt;br&gt;In Java, such a class could look very much like this:&lt;br&gt;&lt;pre&gt;&lt;br&gt;public class Phone {&lt;br&gt;  private String number;&lt;br&gt;  private String type;&lt;/code&gt;&lt;br&gt;&lt;br&gt;  public String getNumber() {&lt;br&gt;    return number;&lt;br&gt;  }&lt;br&gt;  public void setNumber(String number) {&lt;br&gt;    this.number = number;&lt;br&gt;  }&lt;br&gt;  public String getType() {&lt;br&gt;    return type;&lt;br&gt;  }&lt;br&gt;  public void setType(String type) {&lt;br&gt;    this.type = type;&lt;br&gt;  }&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;Quite simple, isn&#39;t it? But we are telling the compiler many things we actually shouldn&#39;t need to. This class is a java bean and as such, among other things, it needs a pair of getters and setters for each of its attributes.&lt;br&gt;&lt;br&gt;Now, on with our example, the same class, in ruby, looks like this:&lt;br&gt;&lt;br&gt;&lt;pre&gt;&lt;br&gt;class Phone&lt;br&gt;  attr_accessor :number, :type&lt;br&gt;end&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;Yeah, I know the feeling. This class has exactly what we need: the two attributes with its own pairs of getters and setters each. But we didn&#39;t need to inform it in the verbose way Java has teached us. Cleaner, period.&lt;br&gt;&lt;br&gt;Now to the code that actually returns the new array containing only mobile numbers. In java, we can do it in two different ways.&lt;br&gt;Using an ArrayList:&lt;br&gt;&lt;br&gt;&lt;pre&gt;&lt;br&gt;//Create two phone objects, one land line and one mobile&lt;br&gt;...&lt;br&gt;// Add them to an array&lt;br&gt;ArrayList&lt;phone&gt; phones = new ArrayList&lt;phone&gt;();&lt;br&gt;phones.add(land);&lt;br&gt;phones.add(mobile);&lt;br&gt;&lt;br&gt;//Return an array only with mobile numbers:&lt;br&gt;private static ArrayList&lt;phone&gt; selectMobilePhones(ArrayList&lt;phone&gt; phones) {&lt;br&gt;&lt;br&gt;  ArrayList&amp;lt;Phone&amp;gt; mobiles = new ArrayList&amp;lt;Phone&amp;gt;();&lt;br&gt;&lt;br&gt;  for (Phone phone : phones) {&lt;br&gt;    if (phone.getType().equals(&#34;mobile&#34;)) {&lt;br&gt;      mobiles.add(phone);&lt;br&gt;    }&lt;br&gt;  }&lt;br&gt;  return mobiles;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;Or using ordinary arrays:&lt;br&gt;&lt;br&gt;&lt;pre&gt;&lt;br&gt;// Assume the same phone objects here&lt;br&gt;...&lt;br&gt;//Add them to the array&lt;br&gt;Phone[] phones = new Phone[]{land, mobile};&lt;br&gt;&lt;br&gt;//Return an array only with mobile numbers:&lt;br&gt;Phone[] mobiles = new Phone[a.length];&lt;br&gt;&lt;br&gt;for (int i = 0; i &amp;lt; a.length; i++) {&lt;br&gt;&lt;br&gt;  if (a[i].getType().equals(&#34;mobile&#34;)) {&lt;br&gt;    mobiles[i] = a[i];&lt;br&gt;  }&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;And you&#39;re good to go. Actually this code with an ArrayList here only looks good thanks to generics. But this is another matter. Let&#39;s take a look at the ruby code that accomplishes de same task:&lt;br&gt;&lt;br&gt;&lt;pre&gt;&lt;br&gt;//Create two phone objects, one land line and one mobile&lt;br&gt;...&lt;br&gt;//Add them to an array&lt;br&gt;phones = [land, mobile]&lt;/code&gt;&lt;br&gt;&lt;br&gt;//Return an array only with mobile numbers:&lt;br&gt;mobiles = phones.select { |phone|&lt;br&gt;   phone.type == &#34;mobile&#34;&lt;br&gt;}&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;See the difference? Java is a great language but too verbose at times. This is a really simple example but if you take the same principle to a bigger app... yeah, you see where I&#39;m going.&lt;br&gt;&lt;br&gt;The bottom line... Ruby may be the language of the lazy programmer, as my friend pointed out. But I don&#39;t mind being called lazy as long as I can type less and be more productive. Do you? :)&#xA;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
