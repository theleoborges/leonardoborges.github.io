<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architecture on Leonardo Borges</title>
    <link>http://leonardoborges.com/tags/architecture/</link>
    <description>Recent content in Architecture on Leonardo Borges</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 Oct 2009 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://leonardoborges.com/tags/architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>a few more thoughts on final classes</title>
      <link>http://leonardoborges.com/writings/2009/10/07/a-few-more-thoughts-on-final-classes/</link>
      <pubDate>Wed, 07 Oct 2009 00:00:00 +0000</pubDate>
      <guid>http://leonardoborges.com/writings/2009/10/07/a-few-more-thoughts-on-final-classes/</guid>
      <description>&lt;p&gt;&#xA;I &lt;a href=&#34;http://www.leonardoborges.com/writings/2009/03/17/final-classes-are-evil/&#34; target=&#34;_blank&#34;&gt;said final classes are evil&lt;/a&gt; and that post got some attention with interesting comments. Maybe because of the title and the tone I wrote it, a few comments didn&#39;t get my real intention and perhaps I should have been more explicit about it. Go ahead and &lt;a href=&#34;http://www.leonardoborges.com/writings/2009/03/17/final-classes-are-evil/&#34; target=&#34;_blank&#34;&gt;read it&lt;/a&gt;. I&#39;ll wait. :)&lt;br&gt;&lt;br&gt;Anyway, I thought I&#39;d expand a little more on that subject, explaining my motivation to write that post and going through the topics I think were raised by my dear readers.&lt;br&gt;&lt;br&gt;First off, final classes &lt;strong&gt;are evil for testing&lt;/strong&gt;. And that&#39;s what it was all about in my previous post.&lt;br&gt;&lt;br&gt;If you depend on a final class, your code will be harder to test. Unless the final class provides an interface that captures its intent - or you wrap that dependency.&lt;br&gt;&lt;br&gt;But this affirmation has some implications that were pointed out by a few comments, some of which I agree with - others, not so much. So let&#39;s start!&lt;br&gt;&lt;br&gt;&lt;strong&gt;- Immutability &lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;span style=&#34;background-color: #ffffff;&#34;&gt;Someone said &#34;Why make a class final ? To make it immutable&#34;. This is not entirely true. Only by marking it final you do not ensure immutability. There is no point in doing that if you provide mutators - e.g. setters. - and don&#39;t declare your members private and final.&lt;/span&gt;&lt;br&gt;&lt;br&gt;I think it&#39;s important to make this clear and understand that the immutability part you achieve by marking a class final is the one of preventing inheritance. Subclasses could possibly contain malicious/careless code and change the internal state of the class.&lt;br&gt;&lt;br&gt;&lt;span style=&#34;background-color: #ffffff;&#34;&gt;But there is another way of preventing subclassing without marking the parent final: declare its constructor private and provide a &lt;a href=&#34;http://www.javapractices.com/topic/TopicAction.do?Id=21&#34; target=&#34;_blank&#34;&gt;static factory&lt;/a&gt;.&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;- Designing for extensibility&lt;/strong&gt;&lt;br&gt;&lt;br&gt;This is hard. It basically means that if you don&#39;t mark a class final, you should document it for inheritance.&lt;br&gt;&lt;br&gt;And this is why inheritance is, in general, a bad OO practice. By documenting the class you basically break encapsulation since you tell the world about your internals.&lt;br&gt;&lt;br&gt;Therefore, the recommendation is to mark a class final if you&#39;re not sure if it&#39;s safe to subclass it - or if you just don&#39;t wanna bother writing documentation and thinking too much about your &#34;client&#34; subclasses.&lt;br&gt;&lt;br&gt;&lt;strong&gt;- Coding against interfaces&lt;/strong&gt;&lt;br&gt;&lt;br&gt;This one is simple but yet often forgotten. Do not code to concrete classes. Always choose interfaces where possible.&lt;br&gt;It roughly means to do this:&lt;br&gt;&lt;pre lang=&#34;java&#34;&gt;  List args = new ArrayList();&lt;/pre&gt;&lt;br&gt;instead of this:&lt;br&gt;&lt;pre lang=&#34;java&#34;&gt;  ArrayList args = new ArrayList();&lt;/pre&gt;&lt;br&gt;By doing so you have the flexibility to not care about the implementation you&#39;re working with, as long as it obeys the interface. That way, the implementations can be swapped at any time without breaking any client&#39;s code.&lt;br&gt;&lt;br&gt;&lt;strong&gt;- The problem with testing&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;&lt;/strong&gt;All items listed here so far are widely regarded as best practices and the bullet I raised about hard testing usually happens when you &#34;violate&#34; some of them.&lt;br&gt;&lt;br&gt;Specifically, if you decide not to design a class for inheritance and mark it as final, it&#39;s wise - in my opinion - to try and capture the class&#39;s intent through an interface.&lt;br&gt;&lt;br&gt;That way you can safely mark your class final and users of your class can easily use the interface to extend it - by favoring &lt;a href=&#34;http://www.artima.com/lejava/articles/designprinciples4.html&#34; target=&#34;_blank&#34;&gt;composition over inheritance&lt;/a&gt; - or by providing it to mocking frameworks for easy testing.&lt;br&gt;&lt;br&gt;&lt;strong&gt;- Conclusion&lt;/strong&gt;&lt;br&gt;&lt;br&gt;I don&#39;t really think there is a rule of thumb here. Java&#39;s standard library shows many examples of both approaches and some of them are now considered bad practices but yet are there for backward compatibility. Nevertheless, these are points to consider when designing your classes.&lt;br&gt;&lt;br&gt;As pointed out by Josua Bloch in his awesome book &lt;a href=&#34;http://www.shelfari.com/books/purchase?EditionId=1523265&amp;amp;AssociateId=leonaborge-20&amp;amp;WidgetId=111594&#34; target=&#34;_blank&#34;&gt;Effective Java&lt;/a&gt;, &#34;If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance&#34;.&lt;br&gt;&lt;br&gt;As usual, comments are more than welcome :)&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>final classes are evil</title>
      <link>http://leonardoborges.com/writings/2009/03/17/final-classes-are-evil/</link>
      <pubDate>Tue, 17 Mar 2009 00:00:00 +0000</pubDate>
      <guid>http://leonardoborges.com/writings/2009/03/17/final-classes-are-evil/</guid>
      <description>&lt;p&gt;&#xA;&lt;strong&gt;Update:&lt;/strong&gt; Go ahead and read this post in its entirety - including the comments. Then, read my other &lt;a href=&#34;http://www.leonardoborges.com/writings/2009/10/07/a-few-more-thoughts-on-final-classes/&#34;&gt;post where I expand the subject a little more&lt;/a&gt;. &lt;br&gt;&lt;br&gt;--&lt;br&gt;&lt;br&gt;Every now and then I still do some Java coding. And I actually like it. I spent several years of my career developing primarily in Java and am very keen about the language.&lt;br&gt;&lt;br&gt;I&#39;ve been a fierce defender of it these days, specially with the wave of popularity of other languages such as Ruby and Groovy. But I must say that for the 1st time - actually the 2nd - I got pissed off at Java.&lt;br&gt;&lt;br&gt;The reason? Final classes!&lt;br&gt;&lt;br&gt;How arrogant of someone to say: &#34;And from now on you shall not subclass my classes!&#34;&lt;br&gt;&lt;br&gt;Er.... Why?!?! I&#39;m yet to find a good reason in favor of it. But I can share 2 that made me be completely against it. - I never actually liked it but it just didn&#39;t bother me that much in the past.&lt;br&gt;&lt;br&gt;The first one happened while I was adding PostgreSQL XML support to &lt;a href=&#34;http://hibernate.org/&#34;&gt;Hibernate&lt;/a&gt;. The basic idea is that the XML data type should behave mostly as a string, with the exception of the saving and loading operations.&lt;br&gt;&lt;br&gt;The thing is, the String data type in Hibernate is declared final. So you cannot share behavior unless you copy and paste it. How smart.&lt;br&gt;&lt;br&gt;And the second is in the testing area. We all love testing. And we all love mocking external dependencies so we can test our code in isolation and fast. Well, I hope your code doesn&#39;t depend on the &lt;a href=&#34;http://java.sun.com/j2se/1.5.0/docs/api/java/net/URL.html&#34;&gt;URL&lt;/a&gt; class then.&lt;br&gt;&lt;br&gt;It is declared final so you just can&#39;t mock it. Mocking frameworks like &lt;a href=&#34;http://www.easymock.org/&#34;&gt;easyMock&lt;/a&gt; use subclassing to create your dependencies mock objects and obviously it doesn&#39;t work here.&lt;br&gt;&lt;br&gt;Yeah yeah, of course you can refactor your code so it depends on an interface/class that wraps your URL class and then you can switch implementations. But just how stupid is that? Programming to interfaces makes sense, but not everywhere. Specially not when you&#39;re using a low level class like this one.&lt;br&gt;&lt;br&gt;So please, software developers, architects and the like, design your systems for extensibility and stop being presumptuous.&lt;br&gt;&lt;br&gt;P.S.: There is a testing framework called &lt;a href=&#34;https://jmockit.dev.java.net/&#34;&gt;jMockit&lt;/a&gt; which uses instrumentation (Java 5+) to redefine methods in runtime so you can mock final classes. It works, but should we really be playing that much with the java class loader just so we can &#34;easily&#34; test our code?&#xA;&lt;/p&gt;</description>
    </item>
    <item>
      <title>spring 25 dependency injection that doesnt hurt</title>
      <link>http://leonardoborges.com/writings/2007/12/07/spring-25-dependency-injection-that-doesnt-hurt/</link>
      <pubDate>Fri, 07 Dec 2007 00:00:00 +0000</pubDate>
      <guid>http://leonardoborges.com/writings/2007/12/07/spring-25-dependency-injection-that-doesnt-hurt/</guid>
      <description>&lt;p&gt;&#xA;&lt;a href=&#34;http://martinfowler.com/articles/injection.html&#34;&gt;Dependency injection&lt;/a&gt; - &lt;a href=&#34;http://martinfowler.com/articles/injection.html&#34;&gt;DI&lt;/a&gt;Â - Â is a great thing. Really. The hability to tweak implementations without touching your code is awesome and the DI frameworks, like spring, saves you a lot of coding. No more service locators stuff.&lt;br&gt;&lt;br&gt;But, and there is always a but, you&#39;re left with a bunch of XML configuration. And I hate it. Not that XML files are bad... the thing is that everything nowadays has its own set of XML configurarion files. And &lt;a href=&#34;http://www.springframework.org&#34;&gt;Spring&lt;/a&gt; is not different.&lt;br&gt;&lt;br&gt;</description>
    </item>
    <item>
      <title>scea 5 beta</title>
      <link>http://leonardoborges.com/writings/2007/10/15/scea-5-beta/</link>
      <pubDate>Mon, 15 Oct 2007 00:00:00 +0000</pubDate>
      <guid>http://leonardoborges.com/writings/2007/10/15/scea-5-beta/</guid>
      <description>&lt;p&gt;&#xA;Hoje fiz a versÃ£o beta da nova prova de arquiteto da Sun e eis algumas impressÃµes:&lt;br&gt;&lt;br&gt;- Ã‰ longa e cansativa... fato justificÃ¡vel se levar-mos em consideraÃ§Ã£o o fato de ser uma prova em estado beta. Ela possui mais questÃµes que a versÃ£o final. SÃ£o 153 questÃµes no total, em 4h e 30min.</description>
    </item>
    <item>
      <title>como o spring me ajudou a manter o active record</title>
      <link>http://leonardoborges.com/writings/2007/10/13/como-o-spring-me-ajudou-a-manter-o-active-record/</link>
      <pubDate>Sat, 13 Oct 2007 00:00:00 +0000</pubDate>
      <guid>http://leonardoborges.com/writings/2007/10/13/como-o-spring-me-ajudou-a-manter-o-active-record/</guid>
      <description>&lt;p&gt;&#xA;Nesse primeiro post vou falar um pouco sobre meu novo trabalho. Na verdade, sobre um problema que encontramos lÃ¡.&lt;br&gt;&lt;br&gt;Dentre diversas coisas que estamos fazendo, como migraÃ§Ãµes por exemplo, estou ajudando na elaboraÃ§Ã£o da arquitetura que irÃ¡ abrigar as novas aplicaÃ§Ãµes desenvolvidas na empresa.</description>
    </item>
  </channel>
</rss>
